


Chapter.8
1、普通的(非内部类)类，不能声明为private或protected；它们只可以被赋予public或者包访问权。
2、当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会保存一个纸箱那个外围类对象的引用。（除了静态内部类（也被称为嵌套类））
3、非静态内部类是无法拥有static属性和方法的，也不能包含嵌套类，但是嵌套类可以包含所有这些东西。


Chapter.9
1、RuntimeException也被称为"未被检查的异常"(unchecked exception)。无需在方法末端现实声明throws

Chapter.10
1、作为程序一部分，每个类都有一个Class对象。换言之，每当你编写并编译了一个雷，就会生成一个Class类对象(更恰当地说，是被保存在一个同名的.class文件中)。
	在运行期，一旦我们想生成这个类的一个对象，运行这个程序的Java虚拟机(JVM)首先会检查这个类的Class对象是否已经加载。如果尚未加载，JVM就会根据类名查
	找.class文件，并将其载入。一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。
2、几种RTTI形式：
	1.经典的类型转换，如"(Shape)",由RTTI确保类型转换的正确性，如果你执行了一个错误的类型转，就会抛出一个ClassCastException异常。
	2.代表对象类型的Class对象。通过查询Class对象可以获取运行期所需的信息。
	3.使用关键字instanceof
3、对instanceof有比较严格的限制：你只可将其与类型的名字进行比较，而不能与Class对象作比较。

Chapter.13
1、volatile关键字：每个线程都可能拥有一个本地栈以维护一些变量的副本。如果把一个变量定义为volatile，就等于告诉编译器不要做任何优化，
	这些优化可能会移除那些使字段与线程里的本地数据副本保持同步的读写操作。
2、线程的四种状态：1、新建(new)；2、就绪(Runnable)；3、死亡(Dead)；4、阻塞(Blocked)；
	线程进入阻塞有几种原因：1、调用了sleep()方法；2、调用了wait()方法；3、线程在等待某个输入/输出完成；4、线程试图在某个对象上调用其同步控制方法，但是对象锁不可用
3、调用sleep()的时候锁并没有被释放；调用wait()方法的时候锁被释放了。	